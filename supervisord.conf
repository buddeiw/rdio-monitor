# Supervisor configuration for Rdio Scanner Monitor Container
# This file manages multiple processes within the container using supervisord
# Ensures proper process lifecycle management and automatic restarts

[unix_http_server]
file=/tmp/supervisor.sock   ; path to your socket file
chmod=0700                  ; socket file mode (default 0700)
chown=appuser:appuser      ; socket file owner

[supervisord]
logfile=/app/logs/supervisord.log ; main log file
logfile_maxbytes=50MB             ; max main logfile bytes b4 rotation
logfile_backups=10                ; number of main logfile backups
loglevel=info                     ; log level
pidfile=/tmp/supervisord.pid      ; supervisord pidfile
nodaemon=false                    ; start in foreground if true
minfds=1024                       ; min. avail startup file descriptors
minprocs=200                      ; min. avail process descriptors
user=appuser                      ; default user
childlogdir=/app/logs            ; where child log files will live

; the below section must remain in the config file for RPC
; (supervisorctl/web interface) to work, additional interfaces may be
; added by defining them in separate rpcinterface: sections
[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; use a unix domain socket

; Main Rdio Scanner Monitor application
[program:rdio-scanner]
command=python3 /app/rdio_scanner.py %(ENV_CONFIG_FILE)s
directory=/app
user=appuser
autostart=true
autorestart=true
startretries=3
startsecs=10
stopwaitsecs=30
stopsignal=TERM
killasgroup=true
stopasgroup=true
redirect_stderr=true
stdout_logfile=/app/logs/rdio-scanner.log
stdout_logfile_maxbytes=100MB
stdout_logfile_backups=5
environment=PYTHONPATH="/app",PYTHONUNBUFFERED="1"

; Health check service (optional internal monitoring)
[program:health-monitor]
command=python3 -c "
import time
import subprocess
import sys
import os

while True:
    try:
        result = subprocess.run([
            'python3', '/app/health_check.py'
        ], capture_output=True, text=True, timeout=30)
        
        if result.returncode == 0:
            print('Health check passed')
        elif result.returncode == 1:
            print('CRITICAL: Health check failed')
            print(result.stdout)
        elif result.returncode == 2:
            print('WARNING: Health check has warnings')
            print(result.stdout)
        else:
            print(f'Health check returned unexpected code: {result.returncode}')
            
    except subprocess.TimeoutExpired:
        print('Health check timed out')
    except Exception as e:
        print(f'Health check error: {e}')
    
    # Sleep for 5 minutes between health checks
    time.sleep(300)
"
directory=/app
user=appuser
autostart=true
autorestart=true
startretries=3
startsecs=5
stopwaitsecs=10
redirect_stderr=true
stdout_logfile=/app/logs/health-monitor.log
stdout_logfile_maxbytes=50MB
stdout_logfile_backups=3
environment=PYTHONPATH="/app"

; Log rotation service
[program:log-rotator]
command=python3 -c "
import time
import os
import glob
import gzip
from datetime import datetime

def rotate_logs():
    log_dir = '/app/logs'
    max_size = 100 * 1024 * 1024  # 100MB
    
    for log_file in glob.glob(os.path.join(log_dir, '*.log')):
        try:
            if os.path.getsize(log_file) > max_size:
                timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
                rotated_name = f'{log_file}.{timestamp}.gz'
                
                # Compress and rotate
                with open(log_file, 'rb') as f_in:
                    with gzip.open(rotated_name, 'wb') as f_out:
                        f_out.writelines(f_in)
                
                # Truncate original log file
                open(log_file, 'w').close()
                print(f'Rotated {log_file} to {rotated_name}')
                
        except Exception as e:
            print(f'Error rotating {log_file}: {e}')

while True:
    try:
        rotate_logs()
    except Exception as e:
        print(f'Log rotation error: {e}')
    
    # Check every hour
    time.sleep(3600)
"
directory=/app
user=appuser
autostart=true
autorestart=true
startretries=3
startsecs=5
stopwaitsecs=10
redirect_stderr=true
stdout_logfile=/app/logs/log-rotator.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2

; Audio cleanup service (manages old audio files)
[program:audio-cleanup]
command=python3 -c "
import time
import os
import glob
from datetime import datetime, timedelta
import configparser

def cleanup_old_audio():
    try:
        # Read configuration
        config = configparser.ConfigParser()
        config_file = os.environ.get('CONFIG_FILE', '/app/config/config.ini')
        
        if not os.path.exists(config_file):
            print(f'Config file not found: {config_file}')
            return
            
        config.read(config_file)
        
        # Get audio settings
        audio_dir = config.get('audio', 'storage_path', fallback='/app/audio')
        retention_days = config.getint('audio', 'retention_days', fallback=30)
        
        if retention_days <= 0:
            print('Audio retention disabled (retention_days <= 0)')
            return
            
        # Calculate cutoff date
        cutoff_date = datetime.now() - timedelta(days=retention_days)
        deleted_count = 0
        deleted_size = 0
        
        # Clean up old audio files
        for audio_file in glob.glob(os.path.join(audio_dir, '*')):
            try:
                if os.path.isfile(audio_file):
                    file_mtime = datetime.fromtimestamp(os.path.getmtime(audio_file))
                    
                    if file_mtime < cutoff_date:
                        file_size = os.path.getsize(audio_file)
                        os.remove(audio_file)
                        deleted_count += 1
                        deleted_size += file_size
                        print(f'Deleted old audio file: {audio_file}')
                        
            except Exception as e:
                print(f'Error processing {audio_file}: {e}')
        
        if deleted_count > 0:
            print(f'Cleanup completed: {deleted_count} files deleted, '
                  f'{deleted_size / (1024*1024):.2f}MB freed')
        else:
            print('No old audio files to clean up')
            
    except Exception as e:
        print(f'Audio cleanup error: {e}')

while True:
    try:
        cleanup_old_audio()
    except Exception as e:
        print(f'Audio cleanup service error: {e}')
    
    # Run cleanup every 6 hours
    time.sleep(21600)
"
directory=/app
user=appuser
autostart=true
autorestart=true
startretries=3
startsecs=5
stopwaitsecs=10
redirect_stderr=true
stdout_logfile=/app/logs/audio-cleanup.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
environment=PYTHONPATH="/app"

; Metrics collection service (optional)
[program:metrics-collector]
command=python3 -c "
import time
import json
import psutil
import os
from datetime import datetime

def collect_system_metrics():
    try:
        # System metrics
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        disk = psutil.disk_usage('/app')
        
        # Process metrics
        process = psutil.Process()
        process_memory = process.memory_info()
        
        metrics = {
            'timestamp': datetime.now().isoformat(),
            'system': {
                'cpu_percent': cpu_percent,
                'memory_total': memory.total,
                'memory_available': memory.available,
                'memory_percent': memory.percent,
                'disk_total': disk.total,
                'disk_used': disk.used,
                'disk_free': disk.free,
                'disk_percent': (disk.used / disk.total) * 100
            },
            'process': {
                'pid': process.pid,
                'memory_rss': process_memory.rss,
                'memory_vms': process_memory.vms,
                'cpu_percent': process.cpu_percent(),
                'num_threads': process.num_threads()
            }
        }
        
        # Write metrics to file for Grafana or other monitoring tools
        metrics_file = '/app/logs/metrics.jsonl'
        with open(metrics_file, 'a') as f:
            f.write(json.dumps(metrics) + '\n')
            
        # Keep only recent metrics (last 24 hours worth)
        if os.path.getsize(metrics_file) > 50 * 1024 * 1024:  # 50MB
            # Rotate metrics file
            os.rename(metrics_file, f'{metrics_file}.old')
            print('Rotated metrics file')
            
    except Exception as e:
        print(f'Metrics collection error: {e}')

while True:
    try:
        collect_system_metrics()
    except Exception as e:
        print(f'Metrics collection service error: {e}')
    
    # Collect metrics every 30 seconds
    time.sleep(30)
"
directory=/app
user=appuser
autostart=false
autorestart=true
startretries=3
startsecs=5
stopwaitsecs=10
redirect_stderr=true
stdout_logfile=/app/logs/metrics-collector.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2

; Simple HTTP health endpoint (for container health checks)
[program:health-endpoint]
command=python3 -c "
from http.server import HTTPServer, BaseHTTPRequestHandler
import json
import subprocess
import threading
import time

class HealthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if self.path == '/health':
            try:
                # Run health check
                result = subprocess.run([
                    'python3', '/app/health_check.py'
                ], capture_output=True, text=True, timeout=10)
                
                if result.returncode == 0:
                    self.send_response(200)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    response = {
                        'status': 'healthy',
                        'timestamp': time.time()
                    }
                    self.wfile.write(json.dumps(response).encode())
                else:
                    self.send_response(503)
                    self.send_header('Content-type', 'application/json')
                    self.end_headers()
                    response = {
                        'status': 'unhealthy',
                        'timestamp': time.time(),
                        'details': result.stdout
                    }
                    self.wfile.write(json.dumps(response).encode())
                    
            except Exception as e:
                self.send_response(500)
                self.send_header('Content-type', 'application/json')
                self.end_headers()
                response = {
                    'status': 'error',
                    'timestamp': time.time(),
                    'error': str(e)
                }
                self.wfile.write(json.dumps(response).encode())
        else:
            self.send_response(404)
            self.end_headers()
    
    def log_message(self, format, *args):
        # Suppress default logging
        pass

# Start HTTP server
port = int(os.environ.get('HEALTH_PORT', '8080'))
server = HTTPServer(('0.0.0.0', port), HealthHandler)
print(f'Health endpoint server started on port {port}')
server.serve_forever()
"
directory=/app
user=appuser
autostart=true
autorestart=true
startretries=3
startsecs=5
stopwaitsecs=10
redirect_stderr=true
stdout_logfile=/app/logs/health-endpoint.log
stdout_logfile_maxbytes=10MB
stdout_logfile_backups=2
environment=PYTHONPATH="/app",HEALTH_PORT="8080"

; Group configuration for easier management
[group:rdio-monitor]
programs=rdio-scanner,health-monitor,log-rotator,audio-cleanup,health-endpoint
priority=999